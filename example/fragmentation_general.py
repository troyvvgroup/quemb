# This script provides a quick overview of the behaviors of the different
# fragmentation schemes available in QuEmb.  For five representative
# systems, we compare trends in the fragments generated by each scheme and
# discuss the intuition and common pitfalls one should keep in mind.
# NOTE: We do not consider PBC in this example.

# Standard imports
import os
import pickle
import time

# For visualizing the collected data
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from pyscf import gto

from quemb.molbe import fragmentate
from quemb.molbe.autofrag import AutogenArgs
from quemb.molbe.chemfrag import ChemGenArgs
from quemb.molbe.graphfrag import GraphGenArgs

# For fetching geometries from `data`, we set the current
# working directory appropriately:
cwd = os.path.dirname(os.path.abspath(__file__))
# For loading in the data if it already exists:
data_file = os.path.join(cwd, "data/frag_data.pkl")

# There are three broad classes of systems that we'll use to
# illustrate the strengths and weaknesses of each fragmenation scheme.
#
# 1. *Hydrogenic systems* (assuming all atoms are equally spaced within
# some lattice) illustrate behavior in an idealized use case. For these
# perfectly homogenous systems, atomic connectivity is trivially defined
# and so we would generally expect the different fragmentation routines
# to all agree.
#
# 2. *Large organic molecules* represent a more practical example. In
# these systems, intramolecular interactions are minimal and the consistency
# of C-C and C-H bond lengths means that atomic connectivity will still be
# unambiguous (assuming all geometries have been equilibriated).
#
# 3. *Non-covalent systems* are a more challenging example.

# 1. Hydrogenic systems: 1D and 2D H-Lattices
lat_a = 1.0
geom_H_1D = [["H", (0.0, 0.0, i * lat_a)] for i in range(20)]
mol_H_1D = gto.M(
    atom=geom_H_1D,
    basis="sto-3g",
).build()

geom_H_2D = [["H", (0.0, j * lat_a, i * lat_a)] for i in range(20) for j in range(20)]
mol_H_2D = gto.M(
    atom=geom_H_2D,
    basis="sto-3g",
).build()

# 2. Large organic molecules: 2D graphene flakes and 1D E-polyacetylene
geom_e_poly = os.path.join(cwd, "data/e_poly_80.xyz")
mol_e_poly = gto.M(
    atom=geom_e_poly,
    basis="sto-3g",
).build()

geom_graphene = os.path.join(cwd, "data/graphene_9by6.xyz")
mol_graphene = gto.M(
    atom=geom_graphene,
    basis="sto-3g",
).build()

# 3. Systems with non-covalent interactions: 64-atom water cluster
# NOTE: this one is courtesy of https://doi.org/10.1039/C4CP05246C.
geom_cluster = os.path.join(cwd, "data/h2o_cluster.xyz")
mol_cluster = gto.M(
    atom=geom_cluster,
    basis="sto-3g",
    spin=0,
    charge=1,
).build()

# The different routines and systems to collect data for:
be_types = [2, 3, 4, 5]
frag_types = ["graphgen", "chemgen", "autogen"]
mol_types = {
    "H_1D": mol_H_1D,
    "H_2D": mol_H_2D,
    "e_poly": mol_e_poly,
    "graphene": mol_graphene,
    "cluster": mol_cluster,
}
results = {}

# Each fragmentation code has its own set of optional parameters:
fragmentate_args = {
    "graphgen": GraphGenArgs(),
    "chemgen": ChemGenArgs(
        treat_H_different=False,
    ),
    "autogen": AutogenArgs(),
}

# Now, loop through all test sets and accumulate fragment data:
if not os.path.exists(data_file):
    result_idx = int(0)
    for frag_type in frag_types:
        for be_type in be_types:
            for mol_type, mol in mol_types.items():
                print(f"Beginning {frag_type}, BE{be_type}, for {mol_type}...")
                t0 = time.time()
                fobj = fragmentate(
                    n_BE=be_type,
                    mol=mol,
                    frag_type=frag_type,
                    print_frags=True,
                    additional_args=fragmentate_args.get(frag_type, None),
                )
                t1 = time.time()
                results.update(
                    {
                        result_idx: {
                            "frag_type": frag_type,
                            "be_type": be_type,
                            "mol_type": mol_type,
                            "time_to_run": t1 - t0,
                            "total_num_atoms": mol.natm,
                            "total_num_electrons": mol.tot_electrons(),
                            "total_num_aos": mol.nao_nr(),
                            "total_num_fragments": len(fobj.AO_per_frag),
                            "all_fragment_sizes": [
                                len(frag) for frag in fobj.AO_per_frag
                            ],
                            "mean_fragment_size": np.mean(
                                [len(frag) for frag in fobj.AO_per_frag]
                            ),
                            "dev_fragment_size": np.std(
                                [len(frag) for frag in fobj.AO_per_frag]
                            ),
                            "max_fragment_size": np.max(
                                [len(frag) for frag in fobj.AO_per_frag]
                            ),
                            "min_fragment_size": np.min(
                                [len(frag) for frag in fobj.AO_per_frag]
                            ),
                            "mean_overlap_size": np.mean(
                                [len(frag) for frag in fobj.AO_per_edge_per_frag]
                            ),
                            "max_overlap_size": np.max(
                                [len(frag) for frag in fobj.AO_per_edge_per_frag]
                            ),
                            "min_overlap_size": np.min(
                                [len(frag) for frag in fobj.AO_per_edge_per_frag]
                            ),
                        }
                    }
                )
                result_idx += 1
    with open(data_file, "wb") as file:
        pickle.dump(results, file)
else:
    with open(data_file, "rb") as file:
        results = pickle.load(file)

# Finally, we can visualize the fragment data and discuss trends:
dataframe = pd.DataFrame(results).transpose()
matrix_of_dataframes = np.empty((len(mol_types), len(be_types)), dtype=object)

for i, mol_type in enumerate(mol_types.keys()):
    _current_df = dataframe.loc[dataframe["mol_type"] == mol_type]
    for j, be_type in enumerate(be_types):
        matrix_of_dataframes[i, j] = _current_df.loc[_current_df["be_type"] == be_type]
        print(matrix_of_dataframes[i, j])

# The idea with the snippet above is to plot 20 different dataframes, arranging
# them like so:
# df_H_1D = dataframe.loc[dataframe["mol_type"] == "H_1D"]
# df_H_1D_2 = df_H_1D.loc[df_H_1D["be_type"] == 2]
# df_H_1D_3 = df_H_1D.loc[df_H_1D["be_type"] == 3]
# df_H_1D_4 = df_H_1D.loc[df_H_1D["be_type"] == 4]
# df_H_1D_5 = df_H_1D.loc[df_H_1D["be_type"] == 5]
# ...repeated for each system. We've arranged the matrix of dataframes to
# have a one-to-one correspondence with the subplots each will correspond
# to. We exclude `be_type == 1` because fragment size would be identical
# for all methods.

xlabels = ["graphgen", "chemgen", "autogen"]
xcolors = ["mediumpurple", "darkseagreen", "peachpuff"]
fs = 10  # fontsize

fig, axs = plt.subplots(
    nrows=5,
    ncols=4,
    figsize=(12, 12),
    sharex=False,
    sharey=False,
    layout="constrained",
)

for i, mol_type in enumerate(mol_types.keys()):
    for j, be_type in enumerate(be_types):
        data = matrix_of_dataframes[i, j]["all_fragment_sizes"]
        _ax = axs[i, j].boxplot(
            data,
            tick_labels=xlabels,
            showmeans=True,
            patch_artist=True,
        )
        axs[i, j].set_title(f"{mol_type} - BE{str(be_type)}", fontsize=fs)
        for patch, color in zip(_ax["boxes"], xcolors):
            patch.set_facecolor(color)
# plt.show()
plt.savefig(os.path.join(cwd, "figures/frag_size_data.png"), dpi=500)

# What we've just generated shows the distribution of fragment sizes (where
# 'size' is defined as the number of uncontracted GTOs per fragment) across
# 5 different kinds of systems (rows) and 4 different values of *n* in BE*n*
# (columns). The shaded boxes give the mean fragment size (along with the
# upper/lower fourth quartiles), orange lines give the median, green
# triangles give the mean, and whiskers give the max and min for the
# distribution. Empty circles correspond to statistical outliers.
#
# What should you take away from these results? A few things...
#
# 1) `graphgen` is currently the most versatile fragmentation code, yielding
# consistent and systematically improvable fragments regardless of the nature
# of the system under study. Most notably: of the three options, `graphgen` is
# the only code that can handle both covalent and non-covalent interactions
# on equal footing. Note, however, that it accomplishes this by re-defining
# the concept of "atomic connectivity" within a fragment, doing away with the
# idea of chemical bonds, and consequently yielding fragments that sometimes
# appear counter-intuitive on first glance. Despite these differences, `graphgen`
# typically yields fragments that are (qualitatively) similar to those of
# `chemgen` and `autogen`.
#
# 2) `chemgen` is remarkably consistent and should be regarded as a more
# complete, predictable version of `autogen`. For any calculations in
# which one desires the conventional BE-type fragment behavior, this option
# should be the first to come to mind. However, as with `autogen`, `chemgen`
# will not work out-of-the-box for more complicated molecular complexes, which
# may be host to a slew of both covalent and non-covalent interactions (as is
# the case in the H2O cluster we consider here.)
#
# 3) `autogen`, despite implementing (in principle) precisely the same
# algorithm as can be found in `chemgen`, often yields qualitatively
# unpredictable results. These differences stem, in part, from unaddressed
# bugs in `autogen`'s implementation, as well as from small difference in
# how atomic connectivity is defined. Note also that `autogen` does *not*
# generalize beyond BE4, whereas both of the alternative schemes will work
# for arbitrary fragment size (BE-985; because, why not).
#
# NOTE: `graphgen` is typically slower than the alternatives, where the
# rate limiting step is the computation of shortest paths from center site
# to all neighboring sites. As a point of ref., for BE5-H_2D (400 atoms in a
# square lattice) `graphgen` takes ~14 seconds where `chemgen` takes ~0.5 s.
#
